"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var __defProp=Object.defineProperty,__name=(e,r)=>__defProp(e,"name",{value:r,configurable:!0}),_helpers=require("@turf/helpers"),_rhumbdestination=require("@turf/rhumb-destination"),_transformrotate=require("@turf/transform-rotate"),_invariant=require("@turf/invariant");function ellipse(e,r,t,i){const o=(i=i||{}).steps||64,a=i.units||"kilometers",n=i.angle||0,s=i.pivot||e,l=i.properties||{};if(!e)throw new Error("center is required");if(!r)throw new Error("xSemiAxis is required");if(!t)throw new Error("ySemiAxis is required");if(!_helpers.isObject.call(void 0,i))throw new Error("options must be an object");if(!_helpers.isNumber.call(void 0,o))throw new Error("steps must be a number");if(!_helpers.isNumber.call(void 0,n))throw new Error("angle must be a number");const u=_invariant.getCoord.call(void 0,e);if("degrees"!==a){const i=_rhumbdestination.rhumbDestination.call(void 0,e,r,90,{units:a}),o=_rhumbdestination.rhumbDestination.call(void 0,e,t,0,{units:a});r=_invariant.getCoord.call(void 0,i)[0]-u[0],t=_invariant.getCoord.call(void 0,o)[1]-u[1]}const p=[];for(let h=0;h<o;h+=1){const e=-360*h/o;let i=r*t/Math.sqrt(Math.pow(t,2)+Math.pow(r,2)*Math.pow(getTanDeg(e),2)),s=r*t/Math.sqrt(Math.pow(r,2)+Math.pow(t,2)/Math.pow(getTanDeg(e),2));if(e<-90&&e>=-270&&(i=-i),e<-180&&e>=-360&&(s=-s),"degrees"===a){const e=_helpers.degreesToRadians.call(void 0,n),r=i*Math.cos(e)+s*Math.sin(e),t=s*Math.cos(e)-i*Math.sin(e);i=r,s=t}p.push([i+u[0],s+u[1]])}return p.push(p[0]),"degrees"===a?_helpers.polygon.call(void 0,[p],l):_transformrotate.transformRotate.call(void 0,_helpers.polygon.call(void 0,[p],l),n,{pivot:s})}function getTanDeg(e){const r=e*Math.PI/180;return Math.tan(r)}__name(ellipse,"ellipse"),__name(getTanDeg,"getTanDeg");var turf_ellipse_default=ellipse;exports.default=turf_ellipse_default,exports.ellipse=ellipse;